
the step-list property:

- every jump offset must make the current address go to the next non-empty addres ( even the current value leads to itself because its offset is 0 ).

- at the end of the step_list, after the last non-empty elm, the offset should go to the last index of the bucket ( will be stored sl->end ).

// TODO maybe we can't offset the jump uintptr by the same amount... because it's offset in bytes, not elms.
// POSSIBLE SOLS:
//      1)
//      two buffers: elm_offsets, offset_offsets
//      the issue with this solution is too much memory usage.
//
//      2)
//      divide the elm_offset by sizeof(SL_TYPE)
//      then multiply the result by sizeof(sl_u)
//      that becomes the jump offset:
//      offset_ptr += ((*offset_ptr) / sizeof(SL_TYPE)) * sizeof(*offset_ptr)
//      THIS ACTUALLY DOESNT MAKE SENSE
//
//      3)
//      make jump_list instead be an array of
//      struct { sl_bucket_t *bucket_of_next_elm ; sl_u index; }
//      or maybe
//      struct { SL_TYPE *next_elm ; sl_u *next_offset; }
//
//     4)
//     do it like struct entry_t { sl_u step; SL_TYPE val; };
//     
//     4 is probably the way to go.
